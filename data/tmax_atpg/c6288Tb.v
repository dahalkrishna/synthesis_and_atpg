// MAX TB Test Protocol File, generated by MAX TB Version U-2022.12
// Sun May 26 17:25:16 2024
// Module under test: c6288
// Generated from original STIL file : "/remote/us01home60/dahal/demo_setup/c17/c6288_patt.stil"
// STIL file version: "1.0"
// Enhanced Runtime Version: use <sim_exec> +tmax_help for available runtime options
// Simulation mode: default parallel simulation

`define TDATA_FILE "/remote/us01home60/dahal/demo_setup/c17/c6288Tb.dat"
`ifndef XTB_DUT_HIER 
  `define XTB_DUT_HIER dut
`endif
`timescale 1ns/1ns

// OPCODE DEFINITION
`define SetLastReseed 0
`define EndPat 1
`define IncPat 2
`define SetPat 3
`define WFTStmt 4
`define ConditionStmt 5
`define VectorStmt 6
`define FixedStmt 7
`define GenLoopStmt 8
`define EndGenLoopStmt 9
`define GenTestSetupStmt 10
`define EndGenTestSetupStmt 11
`define SetForceSI 12
`define SetValidStrobe 13
`define AnnotationStmt 14
`define SetWPack 15
`define SetRPack 16
`define test_setupStmt 17
`define load_unloadStmt 18
`define multiclock_captureStmt 19

// SIGS DEFINITION
`define clk 0
`define reset 1
`define N1_wire 2
`define N18_wire 3
`define N35_wire 4
`define N52_wire 5
`define N69_wire 6
`define N86_wire 7
`define N103_wire 8
`define N120_wire 9
`define N137_wire 10
`define N154_wire 11
`define N171_wire 12
`define N188_wire 13
`define N205_wire 14
`define N222_wire 15
`define N239_wire 16
`define N256_wire 17
`define N273_wire 18
`define N290_wire 19
`define N307_wire 20
`define N324_wire 21
`define N341_wire 22
`define N358_wire 23
`define N375_wire 24
`define N392_wire 25
`define N409_wire 26
`define N426_wire 27
`define N443_wire 28
`define N460_wire 29
`define N477_wire 30
`define N494_wire 31
`define N511_wire 32
`define N528_wire 33
`define si 34
`define se 35
`define N545 36
`define N1581 37
`define N1901 38
`define N2223 39
`define N2548 40
`define N2877 41
`define N3211 42
`define N3552 43
`define N3895 44
`define N4241 45
`define N4591 46
`define N4946 47
`define N5308 48
`define N5672 49
`define N5971 50
`define N6123 51
`define N6150 52
`define N6160 53
`define N6170 54
`define N6180 55
`define N6190 56
`define N6200 57
`define N6210 58
`define N6220 59
`define N6230 60
`define N6240 61
`define N6250 62
`define N6260 63
`define N6270 64
`define N6280 65
`define N6287 66
`define N6288 67
`define so 68
`define _pi 69
`define all_inputs 70
`define _po 71
`define _si 72
`define all_outputs 73
`define _clk 74
`define _so 75

// WFTS DEFINITION
`define _multiclock_capture_WFT_ 0
`define _default_WFT_ 1
`define MAX_PART 0

`define MAXTB_HEADER " MAX TB Version U-2022.12\n Test Protocol File generated from original file \"/remote/us01home60/dahal/demo_setup/c17/c6288_patt.stil\"\n STIL file version: 1.0"
`define MAXTB_H_S "#############################################################################"


module /* maxtb */ c6288_test ();
   parameter NSTMTS = 20; // number of all stmts
   parameter DFSHIFTS = 0; // (default) number of serial shifts in parallel scan mode
   parameter NAMELENGTH = 200; // max length of names reported in fails
   parameter FILELENGTH = 1024; // max length for file names 
   parameter MAXCHLEN = 64, NCHAINS = 1;
   parameter NINPUTS = 36, NOUTPUTS = 33, CUM_WIDTH=211;
   parameter NSIS = 1, NSOUTS = 1;
   parameter WFT_IDS = 2, SIG_IDS = 76, SIG_IDS_W = 7, MAX_WIDTH = 36, MAX_SIGW = 1;
   parameter PARSERINC = 64; 
   parameter SYNC_LATENCY = 3; 
   parameter PRTIME = 0.000000; 
   integer xtb_sim_mode; // simulation modes: xtb_sim_mode=0 -> serial, xtb_sim_mode=1 -> parallel (default);
   integer nbfails, abit, cbit;
   integer prev_error; // flag for tracking displayed error banner
   integer loads;        // number of load_unloads for current pattern
   integer prev_pat;     // previous pattern number;
   integer rep_pat; // report pattern progress every Nth pattern
   integer verbose;      // message verbosity level
   integer debug;      // enable debug level
   integer test_setup_runs; // counts the number of executed test_setups
   integer test_setup_only_once; // flag to trigger only one execution of test_setup
   integer data_i, n, cur_pat, start_pat, end_pat, last_pat, total_pats, csci, fsci, cur_stmt, n_pat_sim;
   integer v_count, v_count_per_pat;  // track the cycle count and cycle/pattern count (helpful for the simulator GUI)
   integer v_count_per_stmt;  // track the cycle count per statement (procedure or macro)
   integer SSHIFTS;
   integer diagf, diagm;
   integer sertmg;
   integer the_wft_id, wft_id_s;
   integer ser_pats;
   integer first_pat;
   event start_part, end_part;
   event error_ev;
   `define NBRTOPS 9
   integer csim_op;
   reg [32*8:1] RT_OPS [0:`NBRTOPS];
   integer      rt_ops [0:`NBRTOPS-1];
   integer      tdfm;
   integer lp_addr, lp_count, lp_max;
   reg [0:(8*FILELENGTH)-1] TDATA_FILE;

   reg [MAX_SIGW*(NINPUTS+NOUTPUTS)-1:0] ALLINSIGS, ALLOUTSIGS;
   reg [MAX_SIGW*(NINPUTS+NOUTPUTS)-1:0] TMPINSIGS_V,TMPINSIGS_T,TMPINSIGS_V_S,TMPINSIGS_T_S;
   reg [MAX_SIGW*(NINPUTS+NOUTPUTS)-1:0] TMPOUTSIGS_V,TMPOUTSIGS_T,TMPOUTSIGS_V_S,TMPOUTSIGS_T_S;
   reg [NINPUTS+NOUTPUTS-1:0] ALLINSIGIDS, ALLOUTSIGIDS, ALLINSIGIDS_S, ALLOUTSIGIDS_S;
   reg [NSTMTS-1:0] opcode, popcode;
   event force_scells;
   event strobe_scells;
   event release_scells;
   reg [78:0] memel, memall [1:307];
   reg [0:(8*NAMELENGTH)-1] CH_NAMES [0:NCHAINS-1];
   reg [0:(8*NAMELENGTH)-1] CH_PINS [0:NCHAINS-1];
   reg [0:MAXCHLEN-1] LOD, LOAD[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] UNL, UNLOAD[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] UNLM;
   reg [0:MAXCHLEN-1] SERIALM;
   reg [0:MAXCHLEN-1] CH_INPINV[0:NCHAINS-1], CH_OUTINV[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] CT_OUTINV[0:NCHAINS-1];
   wire [0:NCHAINS-1] SCANOUT;
   reg [0:MAXCHLEN-1] CHOUT, CHAINOUT[0:NCHAINS-1];
   reg [0:MAXCHLEN-1] CHAINOUT0;
   reg [0:MAXCHLEN-1] LOD0;
   integer set_last_reseed;
   reg strobe_en;
   reg [SIG_IDS-1:0] sid_args ;
   reg [2*CUM_WIDTH-1:0] sval_args;
   reg [6:0] the_sids [0:SIG_IDS-1];
   reg [8*NAMELENGTH-1:0]  SignalIDName [0:75];
   reg [2:0]  SignalIDType [0:75];
   reg [5:0]  SignalIDWidth [0:75];
   reg [(8*NAMELENGTH-1):0]  WFTIDName [0:1];
   reg [0:(8*FILELENGTH)-1] diag_file;
   reg [0:(8*NAMELENGTH-1)] StmtNames [0:NSTMTS];

   reg clk_con ;
   reg reset_con ;
   reg N1_wire_con ;
   reg N18_wire_con ;
   reg N35_wire_con ;
   reg N52_wire_con ;
   reg N69_wire_con ;
   reg N86_wire_con ;
   reg N103_wire_con ;
   reg N120_wire_con ;
   reg N137_wire_con ;
   reg N154_wire_con ;
   reg N171_wire_con ;
   reg N188_wire_con ;
   reg N205_wire_con ;
   reg N222_wire_con ;
   reg N239_wire_con ;
   reg N256_wire_con ;
   reg N273_wire_con ;
   reg N290_wire_con ;
   reg N307_wire_con ;
   reg N324_wire_con ;
   reg N341_wire_con ;
   reg N358_wire_con ;
   reg N375_wire_con ;
   reg N392_wire_con ;
   reg N409_wire_con ;
   reg N426_wire_con ;
   reg N443_wire_con ;
   reg N460_wire_con ;
   reg N477_wire_con ;
   reg N494_wire_con ;
   reg N511_wire_con ;
   reg N528_wire_con ;
   reg si_con ;
   reg se_con ;
   wire N545_con ;
   wire N1581_con ;
   wire N1901_con ;
   wire N2223_con ;
   wire N2548_con ;
   wire N2877_con ;
   wire N3211_con ;
   wire N3552_con ;
   wire N3895_con ;
   wire N4241_con ;
   wire N4591_con ;
   wire N4946_con ;
   wire N5308_con ;
   wire N5672_con ;
   wire N5971_con ;
   wire N6123_con ;
   wire N6150_con ;
   wire N6160_con ;
   wire N6170_con ;
   wire N6180_con ;
   wire N6190_con ;
   wire N6200_con ;
   wire N6210_con ;
   wire N6220_con ;
   wire N6230_con ;
   wire N6240_con ;
   wire N6250_con ;
   wire N6260_con ;
   wire N6270_con ;
   wire N6280_con ;
   wire N6287_con ;
   wire N6288_con ;
   wire so_con ;

   wire [0:(8*NAMELENGTH-1)] cur_StmtName;
   assign cur_StmtName = StmtNames[cur_stmt] ;


   c6288 dut ( 
     .clk ( clk_con ),
     .reset ( reset_con ),
     .N1_wire ( N1_wire_con ),
     .N18_wire ( N18_wire_con ),
     .N35_wire ( N35_wire_con ),
     .N52_wire ( N52_wire_con ),
     .N69_wire ( N69_wire_con ),
     .N86_wire ( N86_wire_con ),
     .N103_wire ( N103_wire_con ),
     .N120_wire ( N120_wire_con ),
     .N137_wire ( N137_wire_con ),
     .N154_wire ( N154_wire_con ),
     .N171_wire ( N171_wire_con ),
     .N188_wire ( N188_wire_con ),
     .N205_wire ( N205_wire_con ),
     .N222_wire ( N222_wire_con ),
     .N239_wire ( N239_wire_con ),
     .N256_wire ( N256_wire_con ),
     .N273_wire ( N273_wire_con ),
     .N290_wire ( N290_wire_con ),
     .N307_wire ( N307_wire_con ),
     .N324_wire ( N324_wire_con ),
     .N341_wire ( N341_wire_con ),
     .N358_wire ( N358_wire_con ),
     .N375_wire ( N375_wire_con ),
     .N392_wire ( N392_wire_con ),
     .N409_wire ( N409_wire_con ),
     .N426_wire ( N426_wire_con ),
     .N443_wire ( N443_wire_con ),
     .N460_wire ( N460_wire_con ),
     .N477_wire ( N477_wire_con ),
     .N494_wire ( N494_wire_con ),
     .N511_wire ( N511_wire_con ),
     .N528_wire ( N528_wire_con ),
     .si ( si_con ),
     .se ( se_con ),
     .N545 ( N545_con ),
     .N1581 ( N1581_con ),
     .N1901 ( N1901_con ),
     .N2223 ( N2223_con ),
     .N2548 ( N2548_con ),
     .N2877 ( N2877_con ),
     .N3211 ( N3211_con ),
     .N3552 ( N3552_con ),
     .N3895 ( N3895_con ),
     .N4241 ( N4241_con ),
     .N4591 ( N4591_con ),
     .N4946 ( N4946_con ),
     .N5308 ( N5308_con ),
     .N5672 ( N5672_con ),
     .N5971 ( N5971_con ),
     .N6123 ( N6123_con ),
     .N6150 ( N6150_con ),
     .N6160 ( N6160_con ),
     .N6170 ( N6170_con ),
     .N6180 ( N6180_con ),
     .N6190 ( N6190_con ),
     .N6200 ( N6200_con ),
     .N6210 ( N6210_con ),
     .N6220 ( N6220_con ),
     .N6230 ( N6230_con ),
     .N6240 ( N6240_con ),
     .N6250 ( N6250_con ),
     .N6260 ( N6260_con ),
     .N6270 ( N6270_con ),
     .N6280 ( N6280_con ),
     .N6287 ( N6287_con ),
     .N6288 ( N6288_con ),
     .so ( so_con )
  );


   task save_context;
     begin
       wft_id_s = the_wft_id;
       TMPINSIGS_V_S = TMPINSIGS_V;
       TMPOUTSIGS_V_S = TMPOUTSIGS_V;
       TMPINSIGS_T_S = TMPINSIGS_T;
       TMPOUTSIGS_T_S = TMPOUTSIGS_T;
       ALLOUTSIGIDS_S = ALLOUTSIGIDS;
       ALLINSIGIDS_S = ALLINSIGIDS;
     end
   endtask 

   task restore_context;
     begin
       the_wft_id = wft_id_s;
       TMPINSIGS_V = TMPINSIGS_V_S;
       TMPOUTSIGS_V = TMPOUTSIGS_V_S;
       TMPINSIGS_T = TMPINSIGS_T_S;
       TMPOUTSIGS_T = TMPOUTSIGS_T_S;
       ALLOUTSIGIDS = ALLOUTSIGIDS_S;
       ALLINSIGIDS = ALLINSIGIDS_S;
     end
   endtask 

   task resolve_signal;
     input reg [6:0] sid;
   begin
     if (SignalIDType[sid] != 3) the_sids[0] = sid;
     else begin
       case (sid)
         'd69: begin // _pi
                 the_sids[35] = 8; the_sids[34] = 9; the_sids[33] = 10; the_sids[32] = 11; the_sids[31] = 12; the_sids[30] = 13; the_sids[29] = 3; the_sids[28] = 2; the_sids[27] = 14; the_sids[26] = 15; the_sids[25] = 16; the_sids[24] = 17; the_sids[23] = 18; the_sids[22] = 19; the_sids[21] = 20; the_sids[20] = 21; the_sids[19] = 22; the_sids[18] = 23; the_sids[17] = 4; the_sids[16] = 24; the_sids[15] = 25; the_sids[14] = 26; the_sids[13] = 27; the_sids[12] = 28; the_sids[11] = 29; the_sids[10] = 30; the_sids[9] = 31; the_sids[8] = 32; the_sids[7] = 33; the_sids[6] = 5; the_sids[5] = 6; the_sids[4] = 7; the_sids[3] = 0; the_sids[2] = 1; the_sids[1] = 34;
                 the_sids[0] = 35;
               end
         'd70: begin // all_inputs
                 the_sids[35] = 8; the_sids[34] = 9; the_sids[33] = 10; the_sids[32] = 11; the_sids[31] = 12; the_sids[30] = 13; the_sids[29] = 3; the_sids[28] = 2; the_sids[27] = 14; the_sids[26] = 15; the_sids[25] = 16; the_sids[24] = 17; the_sids[23] = 18; the_sids[22] = 19; the_sids[21] = 20; the_sids[20] = 21; the_sids[19] = 22; the_sids[18] = 23; the_sids[17] = 4; the_sids[16] = 24; the_sids[15] = 25; the_sids[14] = 26; the_sids[13] = 27; the_sids[12] = 28; the_sids[11] = 29; the_sids[10] = 30; the_sids[9] = 31; the_sids[8] = 32; the_sids[7] = 33; the_sids[6] = 5; the_sids[5] = 6; the_sids[4] = 7; the_sids[3] = 0; the_sids[2] = 1; the_sids[1] = 34;
                 the_sids[0] = 35;
               end
         'd71: begin // _po
                 the_sids[32] = 37; the_sids[31] = 38; the_sids[30] = 39; the_sids[29] = 40; the_sids[28] = 41; the_sids[27] = 42; the_sids[26] = 43; the_sids[25] = 44; the_sids[24] = 45; the_sids[23] = 46; the_sids[22] = 47; the_sids[21] = 48; the_sids[20] = 36; the_sids[19] = 49; the_sids[18] = 50; the_sids[17] = 51; the_sids[16] = 52; the_sids[15] = 53; the_sids[14] = 54; the_sids[13] = 55; the_sids[12] = 56; the_sids[11] = 57; the_sids[10] = 58; the_sids[9] = 59; the_sids[8] = 60; the_sids[7] = 61; the_sids[6] = 62; the_sids[5] = 63; the_sids[4] = 64; the_sids[3] = 65; the_sids[2] = 66; the_sids[1] = 67;
                 the_sids[0] = 68;
               end
         'd72: begin // _si
                
                 the_sids[0] = 34;
               end
         'd73: begin // all_outputs
                 the_sids[32] = 37; the_sids[31] = 38; the_sids[30] = 39; the_sids[29] = 40; the_sids[28] = 41; the_sids[27] = 42; the_sids[26] = 43; the_sids[25] = 44; the_sids[24] = 45; the_sids[23] = 46; the_sids[22] = 47; the_sids[21] = 48; the_sids[20] = 36; the_sids[19] = 49; the_sids[18] = 50; the_sids[17] = 51; the_sids[16] = 52; the_sids[15] = 53; the_sids[14] = 54; the_sids[13] = 55; the_sids[12] = 56; the_sids[11] = 57; the_sids[10] = 58; the_sids[9] = 59; the_sids[8] = 60; the_sids[7] = 61; the_sids[6] = 62; the_sids[5] = 63; the_sids[4] = 64; the_sids[3] = 65; the_sids[2] = 66; the_sids[1] = 67;
                 the_sids[0] = 68;
               end
         'd74: begin // _clk
                 the_sids[1] = 0;
                 the_sids[0] = 1;
               end
         'd75: begin // _so
                
                 the_sids[0] = 68;
               end
          default: begin $display("\nXTB Error: unrecognized signal id %d (valid range is 0..%d). Exiting...",sid, SIG_IDS); $finish; end
       endcase
     end
   end
   endtask

   task get_stb_sig;
     input reg [6:0] sid ;
     output reg [MAX_WIDTH-1:0] strsig;
   begin
     case (sid)
       'd36:	strsig[0:0] = 	N545_con ;
       'd37:	strsig[0:0] = 	N1581_con ;
       'd38:	strsig[0:0] = 	N1901_con ;
       'd39:	strsig[0:0] = 	N2223_con ;
       'd40:	strsig[0:0] = 	N2548_con ;
       'd41:	strsig[0:0] = 	N2877_con ;
       'd42:	strsig[0:0] = 	N3211_con ;
       'd43:	strsig[0:0] = 	N3552_con ;
       'd44:	strsig[0:0] = 	N3895_con ;
       'd45:	strsig[0:0] = 	N4241_con ;
       'd46:	strsig[0:0] = 	N4591_con ;
       'd47:	strsig[0:0] = 	N4946_con ;
       'd48:	strsig[0:0] = 	N5308_con ;
       'd49:	strsig[0:0] = 	N5672_con ;
       'd50:	strsig[0:0] = 	N5971_con ;
       'd51:	strsig[0:0] = 	N6123_con ;
       'd52:	strsig[0:0] = 	N6150_con ;
       'd53:	strsig[0:0] = 	N6160_con ;
       'd54:	strsig[0:0] = 	N6170_con ;
       'd55:	strsig[0:0] = 	N6180_con ;
       'd56:	strsig[0:0] = 	N6190_con ;
       'd57:	strsig[0:0] = 	N6200_con ;
       'd58:	strsig[0:0] = 	N6210_con ;
       'd59:	strsig[0:0] = 	N6220_con ;
       'd60:	strsig[0:0] = 	N6230_con ;
       'd61:	strsig[0:0] = 	N6240_con ;
       'd62:	strsig[0:0] = 	N6250_con ;
       'd63:	strsig[0:0] = 	N6260_con ;
       'd64:	strsig[0:0] = 	N6270_con ;
       'd65:	strsig[0:0] = 	N6280_con ;
       'd66:	strsig[0:0] = 	N6287_con ;
       'd67:	strsig[0:0] = 	N6288_con ;
       'd68:	strsig[0:0] = 	so_con ;
       default: begin $display("\nXTB Error: unrecognized output signal id %d. Exiting...",sid); $finish; end
     endcase
   end
   endtask

   task set_force_sig;
     input reg [SIG_IDS-1:0] sid ;
   begin
     case (sid)
       'd0: clk_con 	= ALLINSIGS[sid];
       'd1: reset_con 	= ALLINSIGS[sid];
       'd2: N1_wire_con 	= ALLINSIGS[sid];
       'd3: N18_wire_con 	= ALLINSIGS[sid];
       'd4: N35_wire_con 	= ALLINSIGS[sid];
       'd5: N52_wire_con 	= ALLINSIGS[sid];
       'd6: N69_wire_con 	= ALLINSIGS[sid];
       'd7: N86_wire_con 	= ALLINSIGS[sid];
       'd8: N103_wire_con 	= ALLINSIGS[sid];
       'd9: N120_wire_con 	= ALLINSIGS[sid];
       'd10: N137_wire_con 	= ALLINSIGS[sid];
       'd11: N154_wire_con 	= ALLINSIGS[sid];
       'd12: N171_wire_con 	= ALLINSIGS[sid];
       'd13: N188_wire_con 	= ALLINSIGS[sid];
       'd14: N205_wire_con 	= ALLINSIGS[sid];
       'd15: N222_wire_con 	= ALLINSIGS[sid];
       'd16: N239_wire_con 	= ALLINSIGS[sid];
       'd17: N256_wire_con 	= ALLINSIGS[sid];
       'd18: N273_wire_con 	= ALLINSIGS[sid];
       'd19: N290_wire_con 	= ALLINSIGS[sid];
       'd20: N307_wire_con 	= ALLINSIGS[sid];
       'd21: N324_wire_con 	= ALLINSIGS[sid];
       'd22: N341_wire_con 	= ALLINSIGS[sid];
       'd23: N358_wire_con 	= ALLINSIGS[sid];
       'd24: N375_wire_con 	= ALLINSIGS[sid];
       'd25: N392_wire_con 	= ALLINSIGS[sid];
       'd26: N409_wire_con 	= ALLINSIGS[sid];
       'd27: N426_wire_con 	= ALLINSIGS[sid];
       'd28: N443_wire_con 	= ALLINSIGS[sid];
       'd29: N460_wire_con 	= ALLINSIGS[sid];
       'd30: N477_wire_con 	= ALLINSIGS[sid];
       'd31: N494_wire_con 	= ALLINSIGS[sid];
       'd32: N511_wire_con 	= ALLINSIGS[sid];
       'd33: N528_wire_con 	= ALLINSIGS[sid];
       'd34: si_con 	= ALLINSIGS[sid];
       'd35: se_con 	= ALLINSIGS[sid];
       default: begin $display("\nXTB Error: unrecognized (input) signal id %d (valid range is 0..%d). Exiting...",sid, SIG_IDS-1); $finish; end
     endcase
   end
   endtask 

   always  begin: force_sigs_p
     reg [SIG_IDS-1:0] sid; 
     reg [MAX_SIGW-1:0] sig;
     fork
        forever @(ALLINSIGS[0]) set_force_sig('d`clk );
        forever @(ALLINSIGS[1]) set_force_sig('d`reset );
        forever @(ALLINSIGS[2]) set_force_sig('d`N1_wire );
        forever @(ALLINSIGS[3]) set_force_sig('d`N18_wire );
        forever @(ALLINSIGS[4]) set_force_sig('d`N35_wire );
        forever @(ALLINSIGS[5]) set_force_sig('d`N52_wire );
        forever @(ALLINSIGS[6]) set_force_sig('d`N69_wire );
        forever @(ALLINSIGS[7]) set_force_sig('d`N86_wire );
        forever @(ALLINSIGS[8]) set_force_sig('d`N103_wire );
        forever @(ALLINSIGS[9]) set_force_sig('d`N120_wire );
        forever @(ALLINSIGS[10]) set_force_sig('d`N137_wire );
        forever @(ALLINSIGS[11]) set_force_sig('d`N154_wire );
        forever @(ALLINSIGS[12]) set_force_sig('d`N171_wire );
        forever @(ALLINSIGS[13]) set_force_sig('d`N188_wire );
        forever @(ALLINSIGS[14]) set_force_sig('d`N205_wire );
        forever @(ALLINSIGS[15]) set_force_sig('d`N222_wire );
        forever @(ALLINSIGS[16]) set_force_sig('d`N239_wire );
        forever @(ALLINSIGS[17]) set_force_sig('d`N256_wire );
        forever @(ALLINSIGS[18]) set_force_sig('d`N273_wire );
        forever @(ALLINSIGS[19]) set_force_sig('d`N290_wire );
        forever @(ALLINSIGS[20]) set_force_sig('d`N307_wire );
        forever @(ALLINSIGS[21]) set_force_sig('d`N324_wire );
        forever @(ALLINSIGS[22]) set_force_sig('d`N341_wire );
        forever @(ALLINSIGS[23]) set_force_sig('d`N358_wire );
        forever @(ALLINSIGS[24]) set_force_sig('d`N375_wire );
        forever @(ALLINSIGS[25]) set_force_sig('d`N392_wire );
        forever @(ALLINSIGS[26]) set_force_sig('d`N409_wire );
        forever @(ALLINSIGS[27]) set_force_sig('d`N426_wire );
        forever @(ALLINSIGS[28]) set_force_sig('d`N443_wire );
        forever @(ALLINSIGS[29]) set_force_sig('d`N460_wire );
        forever @(ALLINSIGS[30]) set_force_sig('d`N477_wire );
        forever @(ALLINSIGS[31]) set_force_sig('d`N494_wire );
        forever @(ALLINSIGS[32]) set_force_sig('d`N511_wire );
        forever @(ALLINSIGS[33]) set_force_sig('d`N528_wire );
        forever @(ALLINSIGS[34]) set_force_sig('d`si );
        forever @(ALLINSIGS[35]) set_force_sig('d`se );
     join
   end

   task measure_out_sig;
     input reg [SIG_IDS-1:0] sid ;
     input integer  stmtid;
     reg [MAX_WIDTH-1:0] xsig;
     reg [MAX_WIDTH-1:0] csig;
     integer errshown, abit, cpat;
   begin
     errshown = 0;
     cpat = cur_pat < 0 ? 0 : cur_pat;
     get_stb_sig(sid,csig);
     xsig = ALLOUTSIGS[sid ];
     for (abit = 0; abit < SignalIDWidth[sid]; abit = abit + 1) begin
       if (xsig[abit] !== 1'bx) begin
         if (xsig[abit] !== csig[abit]) begin
           if (errshown == 0) $display(">>>  Error during %0s pattern %0d", StmtNames[stmtid], cpat);
           if (SignalIDWidth[sid] <= 1) begin 
             $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, signal %0s", $time, v_count, xsig[abit], csig[abit], SignalIDName[sid]);
             if (diagf) begin 
               if (diagm==2) $fdisplay(diagf, "  C %0s %0d (exp=%b, got=%b)", SignalIDName[sid], v_count, xsig[abit], csig[abit]);
               else $fdisplay(diagf, "  %0d %0s (exp=%b, got=%b)", cpat, SignalIDName[sid], xsig[abit], csig[abit]);
             end 
           end 
           else begin 
             $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, signal %0s[%0d]", $time, v_count, xsig[abit], csig[abit], SignalIDName[sid], abit);
             if (diagf) begin 
               if (diagm==2) $fdisplay(diagf, "  C %0s[%0d] %0d (exp=%b, got=%b)", SignalIDName[sid], abit, v_count, xsig[abit], csig[abit]);
               else $fdisplay(diagf, "  %0d %0s[%d] (exp=%b, got=%b)", cpat, SignalIDName[sid], abit, xsig[abit], csig[abit]);
             end 
           end 
           nbfails = nbfails + 1;
           errshown = 1;
           ->error_ev;
         end 
       end 
     end 
   end 
   endtask

   task measure_scan_out;
     input reg [SIG_IDS-1:0] sid ;
     input integer  chain;
     reg [MAX_WIDTH-1:0] xsig;
     reg [MAX_WIDTH-1:0] csig;
     integer errshown, patoff;
   begin
     errshown = 0;
     get_stb_sig(sid, csig);
     xsig = ALLOUTSIGS[sid ];
     if ((xsig[0] !==1'bx) && (xsig[0] !== csig[0])) begin
       patoff = (loads > 1 || cur_pat <= 0) ? 0 : 1;
       if (prev_error != cur_pat) begin
         if (cur_pat <= 0 || cur_pat == last_pat && loads > 1) begin
           $display(">>>  Error during scan pattern %0d %s", (cur_pat < 0) ? 0 : cur_pat,  (cur_pat == last_pat) ? "(detected from final pattern unload)" : "");
         end
         else begin
           if (loads > 1) $display(">>>  Error during scan pattern %0d (detected from %0d load/unload)", cur_pat, loads);
           else begin $display(">>>  Error during scan pattern %0d (detected from unload of pattern %0d)", cur_pat, cur_pat-1); end
         end 
         prev_error = cur_pat;
       end
       $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, chain %0s, pin %0s, scan cell %0d", $time, v_count, xsig[0], csig[0], CH_NAMES[chain], SignalIDName[sid], fsci);
       if (diagf) begin 
         if (diagm==2) $fdisplay(diagf, "  C %0s %0d (exp=%b, got=%b)", SignalIDName[sid], v_count, xsig[0], csig[0]);
          else $fdisplay(diagf, "  %0d %0s %0d (exp=%b, got=%b)", cur_pat-patoff, SignalIDName[sid], fsci, xsig[0], csig[0]);
       end 
       nbfails = nbfails + 1;
       ->error_ev;
             check_max_error_limit;
     end
   end 
   endtask

   always begin: measure_sigs_p
    fork
     forever @(ALLOUTSIGS['d`N545]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N545, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N1581]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N1581, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N1901]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N1901, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N2223]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N2223, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N2548]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N2548, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N2877]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N2877, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N3211]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N3211, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N3552]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N3552, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N3895]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N3895, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N4241]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N4241, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N4591]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N4591, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N4946]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N4946, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N5308]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N5308, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N5672]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N5672, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N5971]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N5971, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6123]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6123, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6150]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6150, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6160]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6160, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6170]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6170, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6180]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6180, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6190]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6190, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6200]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6200, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6210]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6210, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6220]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6220, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6230]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6230, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6240]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6240, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6250]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6250, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6260]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6260, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6270]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6270, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6280]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6280, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6287]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6287, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`N6288]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `multiclock_captureStmt ) measure_out_sig('d`N6288, cur_stmt); 
     end
     forever @(ALLOUTSIGS['d`so]) begin
       #0 if (cur_stmt == `VectorStmt || cur_stmt == `load_unloadStmt || cur_stmt == `multiclock_captureStmt )
       if (cur_stmt ==`load_unloadStmt) measure_scan_out('d`so, 0); 
       else measure_out_sig('d`so, cur_stmt); 
     end
    join
   end 

   task undef_wfc;
     input reg [1:0] wfc;
     input reg [6:0] sid;
     input integer wftid;
   begin
     $display("XTB Error: unrecognized %s value (WFC):%0b, on signal %0s for WFT %0s. Exiting...", wfc[1]?"strobe":"force", wfc[0], SignalIDName[sid], WFTIDName[wftid]);
     $finish;
   end
   endtask

   task apply__multiclock_capture_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd8, 'd9, 'd10, 'd11, 'd12, 'd13, 'd3, 'd2, 'd14, 'd15, 'd16, 'd17, 'd18, 'd19, 'd20, 'd21, 'd22, 'd23, 'd4, 'd24, 'd25, 'd26, 'd27, 'd28, 'd29, 'd30, 'd31, 'd32, 'd33, 'd5, 'd6, 'd7, 'd34, 'd35: // N103_wire, N120_wire, N137_wire, N154_wire, N171_wire, N188_wire, N18_wire, N1_wire, N205_wire, N222_wire, N239_wire, N256_wire, N273_wire, N290_wire, N307_wire, N324_wire, N341_wire, N358_wire, N35_wire, N375_wire, N392_wire, N409_wire, N426_wire, N443_wire, N460_wire, N477_wire, N494_wire, N511_wire, N528_wire, N52_wire, N69_wire, N86_wire, si, se_con
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
         'd37, 'd38, 'd39, 'd40, 'd41, 'd42, 'd43, 'd44, 'd45, 'd46, 'd47, 'd48, 'd36, 'd49, 'd50, 'd51, 'd52, 'd53, 'd54, 'd55, 'd56, 'd57, 'd58, 'd59, 'd60, 'd61, 'd62, 'd63, 'd64, 'd65, 'd66, 'd67, 'd68: // N1581, N1901, N2223, N2548, N2877, N3211, N3552, N3895, N4241, N4591, N4946, N5308, N545, N5672, N5971, N6123, N6150, N6160, N6170, N6180, N6190, N6200, N6210, N6220, N6230, N6240, N6250, N6260, N6270, N6280, N6287, N6288, so_con
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(1) 1'bX;   end
                 2'b11: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(1) 1'b1;   end
                 2'b10: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(1) 1'b0;   end
                 2'b1Z: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(1) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
         'd0: // clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(2) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(3) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
         'd1: // reset
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(2) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(3) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 0);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task apply__default_WFT_WFT;
     reg [SIG_IDS_W-1:0] sid;
     reg [SIG_IDS_W-1:0] n;
     reg [SIG_IDS-1:0] s;
   begin
     for (sid=0; sid < SIG_IDS; sid=sid+1) begin
       n=0; 
       case(sid)
         'd8, 'd9, 'd10, 'd11, 'd12, 'd13, 'd3, 'd2, 'd14, 'd15, 'd16, 'd17, 'd18, 'd19, 'd20, 'd21, 'd22, 'd23, 'd4, 'd24, 'd25, 'd26, 'd27, 'd28, 'd29, 'd30, 'd31, 'd32, 'd33, 'd5, 'd6, 'd7, 'd34, 'd35: // N103_wire, N120_wire, N137_wire, N154_wire, N171_wire, N188_wire, N18_wire, N1_wire, N205_wire, N222_wire, N239_wire, N256_wire, N273_wire, N290_wire, N307_wire, N324_wire, N341_wire, N358_wire, N35_wire, N375_wire, N392_wire, N409_wire, N426_wire, N443_wire, N460_wire, N477_wire, N494_wire, N511_wire, N528_wire, N52_wire, N69_wire, N86_wire, si, se_con
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
         'd0: // clk
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(2) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(3) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
         'd1: // reset
         begin
           if (ALLINSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]})
                 2'b00: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   end
                 2'b01: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b1;   end
                 2'b0Z: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bZ;   end
                 2'b0X: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;   end
                 2'bZ1: begin    ALLINSIGS[MAX_SIGW*sid+n] <=    #(0) 1'b0;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(2) 1'b1;   ALLINSIGS[MAX_SIGW*sid+n] <=    #(3) 1'b0;   end
                 default: undef_wfc({TMPINSIGS_T[MAX_SIGW*sid+n],TMPINSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
         'd37, 'd38, 'd39, 'd40, 'd41, 'd42, 'd43, 'd44, 'd45, 'd46, 'd47, 'd48, 'd36, 'd49, 'd50, 'd51, 'd52, 'd53, 'd54, 'd55, 'd56, 'd57, 'd58, 'd59, 'd60, 'd61, 'd62, 'd63, 'd64, 'd65, 'd66, 'd67, 'd68: // N1581, N1901, N2223, N2548, N2877, N3211, N3552, N3895, N4241, N4591, N4946, N5308, N545, N5672, N5971, N6123, N6150, N6160, N6170, N6180, N6190, N6200, N6210, N6220, N6230, N6240, N6250, N6260, N6270, N6280, N6287, N6288, so_con
         begin
           if (ALLOUTSIGIDS[sid]==1'b1) begin
             for (n=0; n <SignalIDWidth[sid]; n=n+1) begin
               case ({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]})
                 2'b1X: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(1) 1'bX;   end
                 2'b11: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(1) 1'b1;   end
                 2'b10: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(1) 1'b0;   end
                 2'b1Z: begin 
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(0) 1'bX;
                         ALLOUTSIGS[MAX_SIGW*sid+n] <=    #(1) 1'bZ;   end
                 default: undef_wfc({TMPOUTSIGS_T[MAX_SIGW*sid+n],TMPOUTSIGS_V[MAX_SIGW*sid+n]}, sid, 1);
               endcase
             end
           end
         end 
       endcase 
     end 
   end 
   endtask

   task resolve_wft;
     input integer wftid ;
   begin
     if (wftid > WFT_IDS || wftid <0) begin 
       $display("\nXTB Error: undefined WFT id %0d (valid range is 0..%0d). Exiting...",wftid, WFT_IDS);
       $finish;
     end
     the_wft_id = wftid;
   end
   endtask

   task apply_wft; 
     input integer wftid ;
   begin
     case (wftid) 
       'd0: apply__multiclock_capture_WFT_WFT;
       'd1: apply__default_WFT_WFT;
       default:begin $display("\nXTB Error: undefined WFT id %d. Exiting...",wftid); $finish; end
     endcase
   end
   endtask 

   task complete_cycle;
     input integer wft_id ;
   begin
     case(wft_id)
       'd0: #(15); // _multiclock_capture_WFT_
       'd1: #(15); // _default_WFT_
     endcase
   end
   endtask

   task set_args;
     input reg [6:0] nargs;
     integer i, na;
     reg [2*CUM_WIDTH-1:0] sidx;
     reg [SIG_IDS_W-1:0] sid; 
   begin
     na = 0; sid_args = 'b0; sval_args = 'b0;
     while (na < nargs) begin
       data_i = data_i + 1;
       memel = memall[data_i];
       sid = memel[SIG_IDS_W-1:0];
       if (sid > SIG_IDS-1) begin
         $display($time, "\nXTB Error: Passing wrong signal ID (%0b), valid range is 1..%0d. Exiting...", sid, SIG_IDS-1);
         $finish; 
       end
       sid_args[sid] = 1'b1;
       sidx = sig_idx(sid);
       for (i = 0; i < 2*SignalIDWidth[sid]; i = i + 1)
         sval_args[sidx+i] = memel[i+SIG_IDS_W];
       na=na+1; 
    end  
  end 
  endtask

   function [2*CUM_WIDTH-1:0] sig_idx;
     input reg [SIG_IDS_W-1:0] sid;
     integer i; 
   begin
     sig_idx = 0;
     for (i = 0; i < sid; i = i + 1)  sig_idx = sig_idx+2*SignalIDWidth[i]; 
   end 
   endfunction

   task  assign_mval;
     input reg [SIG_IDS_W-1:0] sid;
     input reg [2*MAX_WIDTH-1:0] msval;
     reg [2*CUM_WIDTH-1:0] sidx;
     reg [2*MAX_WIDTH-1:0] sval;
     integer i;
   begin 
     sidx = sig_idx(sid);
     for (i = 0; i<2*SignalIDWidth[sid]; i = i + 1) sval[i] = (msval[SignalIDWidth[sid] + i] !== 1'bx && i < SignalIDWidth[sid]) ? msval[i] : sval_args[sidx+i]  ;
     assign_val(sid , sval);
   end 
   endtask

   task  assign_ival;
     input reg [SIG_IDS_W-1:0] sid;
     reg [2*CUM_WIDTH-1:0] sidx;
     reg [2*MAX_WIDTH-1:0] sval;
     integer i;
   begin 
     sidx = sig_idx(sid);
     for (i = 0; i<2*SignalIDWidth[sid]; i = i + 1) sval[i] = sval_args[sidx+i];
     assign_val(sid , sval);
   end 
   endtask

   task  assign_val;
     input reg [SIG_IDS_W-1:0] sid;
     input reg [2*MAX_WIDTH-1:0] sval;
     reg [MAX_WIDTH-1:0] nb; 
     reg [8:0] idx;
     integer n, ns;
   begin
     if (sid > SIG_IDS-1 || sid < 0) begin
       $display("\nXTB Error: Passing wrong signal ID (%d), valid range is 1..%0d. Exiting...", sid, SIG_IDS-1);
       $finish;
     end
     resolve_signal(sid);
     idx = 0; 
     ns = (SignalIDType[sid]==3) ? SignalIDWidth[sid] : 1;
     for (n = 0; n < ns; n = n + 1)
     begin
       if (sval[idx+SignalIDWidth[sid]] === 1'b1) begin
         for (nb = 0; nb < SignalIDWidth[the_sids[n]]; nb = nb + 1) begin
           TMPOUTSIGS_V[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb];
           TMPOUTSIGS_T[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb+SignalIDWidth[sid]];
           ALLOUTSIGIDS[the_sids[n]] = 1'b1; 
           if (sval[idx+nb] !== 1'bx)
             ALLINSIGIDS[the_sids[n]] = 1'b0;
         end
       end
       else begin
         for (nb = 0; nb < SignalIDWidth[the_sids[n]]; nb = nb + 1) begin
           TMPINSIGS_V[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb];
           TMPINSIGS_T[MAX_SIGW*the_sids[n]+nb]  = sval[idx+nb+SignalIDWidth[sid]];
           ALLINSIGIDS[the_sids[n]] = 1'b1;
           ALLOUTSIGIDS[the_sids[n]] = 1'b0;
       end 
     end
     idx = idx+SignalIDWidth[the_sids[n]];
     end 
   end 
   endtask

   task  check_sid_args;
     input reg [(NAMELENGTH-1):0] tname;
     input reg [SIG_IDS-1:0] vargs ;
     input reg [SIG_IDS-1:0] cargs ;
     integer i;
   begin
     for (i = 0; i < SIG_IDS-1; i = i + 1)
       if (cargs[i] === 1'b1 && vargs[i] !== 1'b1) begin
         $display("\nXTB Error: Passing wrong signal argument (%s), to Macro/Procedure %s. Exiting...", SignalIDName[i], tname); 
         $finish;
       end 
   end 
   endtask

   task  assign_stmt;
     input integer wftid ;
   begin
     v_count = v_count+1;
     v_count_per_pat = v_count_per_pat+1;
     v_count_per_stmt = v_count_per_stmt+1;
     if (verbose >= 4) $display("XTB: Starting V# %0d at time %0t", v_count, $time);
     apply_wft(wftid);
     complete_cycle(wftid);
   end
   endtask

   task display_stmt;
     input integer stmtid;
   begin
     $display("XTB: Processed statement: %0s", StmtNames[stmtid]);
   end
   endtask

   task read_data;
     integer tdf;
   begin
     tdf = $fopen(TDATA_FILE, "r");
     if (!tdf) begin 
       $display("XTB Error: cannot open %0s file. Exiting...\n", TDATA_FILE);
       $finish; 
      end 
      $fclose(tdf); 
     if (tdfm > 0) $display("XTB: Setting test data file to \"%0s\" (at %0s). Running simulation with new database...", TDATA_FILE, tdfm==1?"compile-time":"runtime");
     else if (verbose >= 1) $display("XTB: Reading test data file \"%0s\" ", TDATA_FILE);
     $readmemb(TDATA_FILE, memall);
   end
    endtask

   task measure_chain_out;
     input reg [NCHAINS-1:0] chid;
     integer bi, errshown, patoff, prefo;
     integer tsc;
     reg [0:MAXCHLEN-1] UNLM;
   begin
     tsc = 0;
     prefo = 0;
     UNLM = ~('b0);
     CHAINOUT[0] = (CHAINOUT0);
     UNL = UNLOAD[chid] << prefo;
     CHOUT = CHAINOUT[chid] ^ CH_OUTINV[chid] ^ CT_OUTINV[chid];

     for (bi = 0; bi < MAXCHLEN; bi = bi + 1)
       if (UNL[bi] === 1'bx) UNLM[bi] = 1'b0;

     for (bi = 0; bi < prefo; bi = bi + 1) UNLM[MAXCHLEN-1-bi] = 1'b0;

     if ((UNL&UNLM) !== (CHOUT&UNLM)) begin
       patoff = (loads > 1 || cur_pat <= 0) ? 0 : 1;
     if (cur_pat <= 0 || cur_pat == last_pat && loads > 1) begin
       $display(">>>  Error during scan pattern %0d %s", (cur_pat<0)?0:cur_pat, (cur_pat==last_pat)?"(detected from final parallel pattern unload)":"");
     end
     else begin
       if (loads > 1) $display(">>>  Error during scan pattern %0d (detected from %0d parallel load/unload)", cur_pat, loads);
       else begin $display(">>>  Error during scan pattern %0d (detected from parallel unload of pattern %0d)", cur_pat, cur_pat-1); end
     end
       for (bi = 0; bi < MAXCHLEN-prefo; bi=bi + 1) begin
         if ((UNL[bi] !== 1'bx) && (UNL[bi] !== CHOUT[bi])) begin
           $display(">>>  \tAt T=%0t, V=%0d, exp=%b, got=%b, chain %0s, pin %0s, scan cell %0d", $time, sertmg?v_count+1+bi+prefo:v_count, UNL[bi], CHOUT[bi], CH_NAMES[chid], CH_PINS[chid], bi+prefo+tsc);
           if (diagf) begin 
           if (diagm==2) $fdisplay(diagf, "  C %0s %0d (exp=%b, got=%b) ", CH_PINS[chid], v_count, UNL[bi], CHOUT[bi]);
           else $fdisplay(diagf, "  %0d %0s %0d (exp=%b, got=%b)",
               cur_pat-patoff, CH_PINS[chid], bi+prefo+tsc, UNL[bi], CHOUT[bi]);
           end 
           nbfails = nbfails + 1;
           ->error_ev;
       check_max_error_limit;
          end 
       end  
     end
   end 
   endtask

   task test_setup ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     v_count_per_stmt = 0;
     if (test_setup_only_once > 0 && test_setup_runs > 0) begin
       if (verbose >= 2) $display("XTB: Skipping macro test_setup...");
       disable test_setup;
     end
     test_setup_runs = test_setup_runs + 1;
     if (verbose >= 2) $display("XTB: Starting macro test_setup..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("test_setup",76'b1, idargs);
     resolve_wft(1);

     assign_val('d`all_inputs , 72'b000000000000000000000000000000000000XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX);
     assign_val('d`all_outputs , 66'b111111111111111111111111111111111XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX);

     assign_val('d`clk , 2'b00);
     assign_val('d`reset , 2'b00);
     assign_stmt(the_wft_id);

     assign_stmt(the_wft_id);

   end 
   endtask

   task shift_0 ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
     input integer stsci;
     input reg stroben;
   begin
    csci = stsci+0; prev_error = -2;
    while (csci < 64) begin
     fsci = csci;
     if (verbose >= 2) $display("XTB: shift %0d, at %0t ", csci, $time);
     resolve_wft(1);
     assign_val('d`_clk , 4'bZ010);
         if (idargs[72] === 1'b1 || idargs[34] === 1'b1) begin 
           LOD=LOAD[0]; assign_val('d`si , {1'b0, LOD[csci+0]});
         end
         if(stroben && (idargs[75] === 1'b1 || idargs[68] === 1'b1)) begin 
           UNL = UNLOAD[0]; assign_val('d`so , {1'b1,  UNL[csci+0]});
         end
     assign_stmt(the_wft_id);
     csci = csci+1;
    end
   end
   endtask


   always /* ParallelShiftMode */ @(strobe_scells) begin
     CHAINOUT0[0:31] = {`XTB_DUT_HIER.N6288_reg.Q , `XTB_DUT_HIER.N6287_reg.QN , `XTB_DUT_HIER.N6280_reg.QN , `XTB_DUT_HIER.N6270_reg.QN , `XTB_DUT_HIER.N6260_reg.QN , `XTB_DUT_HIER.N6250_reg.QN , `XTB_DUT_HIER.N6240_reg.QN , `XTB_DUT_HIER.N6230_reg.QN , `XTB_DUT_HIER.N6220_reg.QN , `XTB_DUT_HIER.N6210_reg.QN , `XTB_DUT_HIER.N6200_reg.QN , `XTB_DUT_HIER.N6190_reg.QN , `XTB_DUT_HIER.N6180_reg.QN , `XTB_DUT_HIER.N6170_reg.QN , `XTB_DUT_HIER.N6160_reg.QN , `XTB_DUT_HIER.N6150_reg.QN , `XTB_DUT_HIER.N6123_reg.QN , `XTB_DUT_HIER.N5971_reg.QN , `XTB_DUT_HIER.N5672_reg.QN , `XTB_DUT_HIER.N5308_reg.QN , `XTB_DUT_HIER.N4946_reg.QN , `XTB_DUT_HIER.N4591_reg.QN , `XTB_DUT_HIER.N4241_reg.QN , `XTB_DUT_HIER.N3895_reg.QN , `XTB_DUT_HIER.N3552_reg.QN , `XTB_DUT_HIER.N3211_reg.QN , `XTB_DUT_HIER.N2877_reg.QN , `XTB_DUT_HIER.N2548_reg.QN , `XTB_DUT_HIER.N2223_reg.QN , `XTB_DUT_HIER.N1901_reg.QN , `XTB_DUT_HIER.N1581_reg.QN , `XTB_DUT_HIER.N545_reg.QN };
     CHAINOUT0[32:63] = {`XTB_DUT_HIER.N528_reg.QN , `XTB_DUT_HIER.N511_reg.QN , `XTB_DUT_HIER.N494_reg.QN , `XTB_DUT_HIER.N477_reg.QN , `XTB_DUT_HIER.N460_reg.QN , `XTB_DUT_HIER.N443_reg.QN , `XTB_DUT_HIER.N426_reg.QN , `XTB_DUT_HIER.N409_reg.QN , `XTB_DUT_HIER.N392_reg.QN , `XTB_DUT_HIER.N375_reg.QN , `XTB_DUT_HIER.N358_reg.QN , `XTB_DUT_HIER.N341_reg.QN , `XTB_DUT_HIER.N324_reg.QN , `XTB_DUT_HIER.N307_reg.QN , `XTB_DUT_HIER.N290_reg.QN , `XTB_DUT_HIER.N273_reg.QN , `XTB_DUT_HIER.N256_reg.Q , `XTB_DUT_HIER.N239_reg.Q , `XTB_DUT_HIER.N222_reg.QN , `XTB_DUT_HIER.N205_reg.QN , `XTB_DUT_HIER.N188_reg.QN , `XTB_DUT_HIER.N171_reg.QN , `XTB_DUT_HIER.N154_reg.QN , `XTB_DUT_HIER.N137_reg.QN , `XTB_DUT_HIER.N120_reg.QN , `XTB_DUT_HIER.N103_reg.QN , `XTB_DUT_HIER.N86_reg.QN , `XTB_DUT_HIER.N69_reg.QN , `XTB_DUT_HIER.N52_reg.QN , `XTB_DUT_HIER.N35_reg.QN , `XTB_DUT_HIER.N18_reg.QN , `XTB_DUT_HIER.N1_reg.QN };
   end

   `define CELL0IN0 `XTB_DUT_HIER.N1_reg.SI
   `define CHAININ0 {`XTB_DUT_HIER.N6288_reg.SI , `XTB_DUT_HIER.N6287_reg.SI , `XTB_DUT_HIER.N6280_reg.SI , `XTB_DUT_HIER.N6270_reg.SI , `XTB_DUT_HIER.N6260_reg.SI , `XTB_DUT_HIER.N6250_reg.SI , `XTB_DUT_HIER.N6240_reg.SI , `XTB_DUT_HIER.N6230_reg.SI , `XTB_DUT_HIER.N6220_reg.SI , `XTB_DUT_HIER.N6210_reg.SI , `XTB_DUT_HIER.N6200_reg.SI , `XTB_DUT_HIER.N6190_reg.SI , `XTB_DUT_HIER.N6180_reg.SI , `XTB_DUT_HIER.N6170_reg.SI , `XTB_DUT_HIER.N6160_reg.SI , `XTB_DUT_HIER.N6150_reg.SI , \
	`XTB_DUT_HIER.N6123_reg.SI , `XTB_DUT_HIER.N5971_reg.SI , `XTB_DUT_HIER.N5672_reg.SI , `XTB_DUT_HIER.N5308_reg.SI , `XTB_DUT_HIER.N4946_reg.SI , `XTB_DUT_HIER.N4591_reg.SI , `XTB_DUT_HIER.N4241_reg.SI , `XTB_DUT_HIER.N3895_reg.SI , `XTB_DUT_HIER.N3552_reg.SI , `XTB_DUT_HIER.N3211_reg.SI , `XTB_DUT_HIER.N2877_reg.SI , `XTB_DUT_HIER.N2548_reg.SI , `XTB_DUT_HIER.N2223_reg.SI , `XTB_DUT_HIER.N1901_reg.SI , `XTB_DUT_HIER.N1581_reg.SI , `XTB_DUT_HIER.N545_reg.SI , `XTB_DUT_HIER.N528_reg.SI , `XTB_DUT_HIER.N511_reg.SI , `XTB_DUT_HIER.N494_reg.SI , `XTB_DUT_HIER.N477_reg.SI , `XTB_DUT_HIER.N460_reg.SI , `XTB_DUT_HIER.N443_reg.SI , `XTB_DUT_HIER.N426_reg.SI , `XTB_DUT_HIER.N409_reg.SI , `XTB_DUT_HIER.N392_reg.SI , `XTB_DUT_HIER.N375_reg.SI , `XTB_DUT_HIER.N358_reg.SI , `XTB_DUT_HIER.N341_reg.SI , `XTB_DUT_HIER.N324_reg.SI , `XTB_DUT_HIER.N307_reg.SI , `XTB_DUT_HIER.N290_reg.SI , `XTB_DUT_HIER.N273_reg.SI , `XTB_DUT_HIER.N256_reg.SI , `XTB_DUT_HIER.N239_reg.SI , `XTB_DUT_HIER.N222_reg.SI , `XTB_DUT_HIER.N205_reg.SI , `XTB_DUT_HIER.N188_reg.SI , `XTB_DUT_HIER.N171_reg.SI , `XTB_DUT_HIER.N154_reg.SI , `XTB_DUT_HIER.N137_reg.SI , `XTB_DUT_HIER.N120_reg.SI , `XTB_DUT_HIER.N103_reg.SI , `XTB_DUT_HIER.N86_reg.SI , `XTB_DUT_HIER.N69_reg.SI , `XTB_DUT_HIER.N52_reg.SI , `XTB_DUT_HIER.N35_reg.SI , `XTB_DUT_HIER.N18_reg.SI ,  `CELL0IN0 }


   task p_shift_0 ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
     integer i, j;
   begin
     if (~(idargs[72] | idargs[34] | idargs[75] | idargs[68] )) 
       disable p_shift_0 ; 
     if (SSHIFTS < MAXCHLEN) begin
         if (verbose >= 2) $display("XTB: (parallel) shift, at %0t  ", $time);
         resolve_wft(1);
     fork 
       begin: b1 
         #1 ;
         -> strobe_scells;
         repeat (SYNC_LATENCY) #0;
         if (idargs[75] === 1'b1 ||  idargs[68] === 1'b1) begin 
           measure_chain_out('d0);
         end
         if (idargs[72] === 1'b1 ||  idargs[34] === 1'b1) begin 
           LOD0=(LOAD[0] >> SSHIFTS) ^ CH_INPINV[0];
         end

           ->force_scells; 
         #0;
       end 
       begin: b2
         assign_val('d`_clk , 4'bZ010);
         assign_stmt(the_wft_id);
       end 
     join 

     ->release_scells; 

         #0;
         if (sertmg == 1) begin
           v_count = v_count + PARSERINC - SSHIFTS - 1;
           for (i = 0; i < PARSERINC - SSHIFTS - 1; i = i+1)
             complete_cycle(the_wft_id);
         end
         if (SSHIFTS > 0) shift_0(idargs, valargs, MAXCHLEN-SSHIFTS, 0) ; 

     end 
     else begin 
         shift_0(idargs, valargs, 0, 1);
     end
   end
   endtask


   always /* ParallelShiftMode */ @(force_scells) begin 
           force `CHAININ0 = LOD0;

   end


   always /* ParallelShiftMode */ @(release_scells) begin 
     release `CHAININ0; 
   end

   task load_unload ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     v_count_per_stmt = 0;
     if (verbose >= 2) $display("XTB: Starting proc load_unload..., T=%0t, V=%0d", $time, v_count+1);

     if (xtb_sim_mode == 0 && ser_pats > 0 && cur_pat < last_pat && cur_pat == (ser_pats+first_pat)) begin
       $display("XTB: Switching into Parallel simulation mode at pattern %0d (using %0d serial shifts)", cur_pat, SSHIFTS);
       xtb_sim_mode = 1; 
     end
     if (cur_pat != prev_pat) begin
       loads = 1;
       prev_pat = cur_pat;
       if (cur_pat % rep_pat == 0)
         $display("XTB: Begin %0s scan load for pattern %0d (T=%0t, V=%0d)", xtb_sim_mode?"parallel":"serial", cur_pat, $time, v_count+1);
     end
     else begin
       loads = loads + 1;
       if (cur_pat % rep_pat == 0)
         $display("XTB: Begin %0s scan load for pattern %0d, unload %0d (T=%0t, V=%0d)", xtb_sim_mode?"parallel":"serial", cur_pat, loads, $time, v_count+1);
     end
     save_context;
     resolve_wft(1);

     assign_val('d`all_inputs , 72'b000000000000000000000000000000000000XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX00XX);
     assign_val('d`all_outputs , 66'b111111111111111111111111111111111XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX);

     assign_val('d`se , 2'b01);
     assign_stmt(the_wft_id);

     if (xtb_sim_mode)      p_shift_0(idargs, valargs);
     else      shift_0(idargs, valargs, 0, 1);

     restore_context;
   end 
   endtask

   task multiclock_capture ;
     input reg [SIG_IDS-1:0] idargs;
     input reg [2*CUM_WIDTH-1:0] valargs;
   begin
     v_count_per_stmt = 0;
     if (verbose >= 2) $display("XTB: Starting proc multiclock_capture..., T=%0t, V=%0d", $time, v_count+1);
     //check_sid_args("multiclock_capture",76'b1, idargs);
     save_context;
     resolve_wft(0);

     assign_val('d`all_inputs , 72'b000000000000000000000000000000000000XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX00XX);
     assign_val('d`all_outputs , 66'b111111111111111111111111111111111XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX);

     if (idargs[69] === 1'b1) assign_ival('d`_pi );
     if (idargs[8] === 1'b1) assign_ival('d`N103_wire );
     if (idargs[9] === 1'b1) assign_ival('d`N120_wire );
     if (idargs[10] === 1'b1) assign_ival('d`N137_wire );
     if (idargs[11] === 1'b1) assign_ival('d`N154_wire );
     if (idargs[12] === 1'b1) assign_ival('d`N171_wire );
     if (idargs[13] === 1'b1) assign_ival('d`N188_wire );
     if (idargs[3] === 1'b1) assign_ival('d`N18_wire );
     if (idargs[2] === 1'b1) assign_ival('d`N1_wire );
     if (idargs[14] === 1'b1) assign_ival('d`N205_wire );
     if (idargs[15] === 1'b1) assign_ival('d`N222_wire );
     if (idargs[16] === 1'b1) assign_ival('d`N239_wire );
     if (idargs[17] === 1'b1) assign_ival('d`N256_wire );
     if (idargs[18] === 1'b1) assign_ival('d`N273_wire );
     if (idargs[19] === 1'b1) assign_ival('d`N290_wire );
     if (idargs[20] === 1'b1) assign_ival('d`N307_wire );
     if (idargs[21] === 1'b1) assign_ival('d`N324_wire );
     if (idargs[22] === 1'b1) assign_ival('d`N341_wire );
     if (idargs[23] === 1'b1) assign_ival('d`N358_wire );
     if (idargs[4] === 1'b1) assign_ival('d`N35_wire );
     if (idargs[24] === 1'b1) assign_ival('d`N375_wire );
     if (idargs[25] === 1'b1) assign_ival('d`N392_wire );
     if (idargs[26] === 1'b1) assign_ival('d`N409_wire );
     if (idargs[27] === 1'b1) assign_ival('d`N426_wire );
     if (idargs[28] === 1'b1) assign_ival('d`N443_wire );
     if (idargs[29] === 1'b1) assign_ival('d`N460_wire );
     if (idargs[30] === 1'b1) assign_ival('d`N477_wire );
     if (idargs[31] === 1'b1) assign_ival('d`N494_wire );
     if (idargs[32] === 1'b1) assign_ival('d`N511_wire );
     if (idargs[33] === 1'b1) assign_ival('d`N528_wire );
     if (idargs[5] === 1'b1) assign_ival('d`N52_wire );
     if (idargs[6] === 1'b1) assign_ival('d`N69_wire );
     if (idargs[7] === 1'b1) assign_ival('d`N86_wire );
     if (idargs[0] === 1'b1) assign_ival('d`clk );
     if (idargs[1] === 1'b1) assign_ival('d`reset );
     if (idargs[34] === 1'b1) assign_ival('d`si );
     if (idargs[35] === 1'b1) assign_ival('d`se );
     if (idargs[71] === 1'b1) assign_ival('d`_po );
     if (idargs[37] === 1'b1) assign_ival('d`N1581 );
     if (idargs[38] === 1'b1) assign_ival('d`N1901 );
     if (idargs[39] === 1'b1) assign_ival('d`N2223 );
     if (idargs[40] === 1'b1) assign_ival('d`N2548 );
     if (idargs[41] === 1'b1) assign_ival('d`N2877 );
     if (idargs[42] === 1'b1) assign_ival('d`N3211 );
     if (idargs[43] === 1'b1) assign_ival('d`N3552 );
     if (idargs[44] === 1'b1) assign_ival('d`N3895 );
     if (idargs[45] === 1'b1) assign_ival('d`N4241 );
     if (idargs[46] === 1'b1) assign_ival('d`N4591 );
     if (idargs[47] === 1'b1) assign_ival('d`N4946 );
     if (idargs[48] === 1'b1) assign_ival('d`N5308 );
     if (idargs[36] === 1'b1) assign_ival('d`N545 );
     if (idargs[49] === 1'b1) assign_ival('d`N5672 );
     if (idargs[50] === 1'b1) assign_ival('d`N5971 );
     if (idargs[51] === 1'b1) assign_ival('d`N6123 );
     if (idargs[52] === 1'b1) assign_ival('d`N6150 );
     if (idargs[53] === 1'b1) assign_ival('d`N6160 );
     if (idargs[54] === 1'b1) assign_ival('d`N6170 );
     if (idargs[55] === 1'b1) assign_ival('d`N6180 );
     if (idargs[56] === 1'b1) assign_ival('d`N6190 );
     if (idargs[57] === 1'b1) assign_ival('d`N6200 );
     if (idargs[58] === 1'b1) assign_ival('d`N6210 );
     if (idargs[59] === 1'b1) assign_ival('d`N6220 );
     if (idargs[60] === 1'b1) assign_ival('d`N6230 );
     if (idargs[61] === 1'b1) assign_ival('d`N6240 );
     if (idargs[62] === 1'b1) assign_ival('d`N6250 );
     if (idargs[63] === 1'b1) assign_ival('d`N6260 );
     if (idargs[64] === 1'b1) assign_ival('d`N6270 );
     if (idargs[65] === 1'b1) assign_ival('d`N6280 );
     if (idargs[66] === 1'b1) assign_ival('d`N6287 );
     if (idargs[67] === 1'b1) assign_ival('d`N6288 );
     if (idargs[68] === 1'b1) assign_ival('d`so );
     assign_stmt(the_wft_id);

     restore_context;
   end 
   endtask


   always @(start_part) begin: _burst__pattern__proc_unit

     integer nbpats, i;
     integer nargs, na;
     integer args;

     integer tdf;
     nbpats = 0; cur_pat = -1;
     loads = 1;

     end_pat = 0; v_count = 0; v_count_per_pat = 0; v_count_per_stmt = 0;
     nbfails = 0;
     prev_pat = -2; prev_error = -2; first_pat = 0;
     diagf = 0;
     if ( $value$plusargs ("tmax_diag_file=%s", diag_file )) diagm = diagm ? diagm : 1;
     read_data;
     data_i = 1; 
     popcode = 'd0;

     if (diagm > 0) begin
       if (diagm > 2) begin
         $display("XTB Warning: wrong diagnosis mode (%0d), using default mode 1 (pattern based)", diagm);
         diagm = 1 ; 
       end  
       if ( $value$plusargs ("tmax_diag_file=%s", diag_file )) begin
         $display("XTB: Setting run-time option \"tmax_diag_file\" to %0s .",diag_file);
       end 
       else begin
         `ifdef tmax_diag_file 
         diag_file = `tmax_diag_file;
         `else  diag_file = "c6288Tb.diag"; 
         `endif 
       end
       diagf = $fopen(diag_file);
       if (diagf == 0) begin
         $display("XTB Error: Unable to open diagnosis file %s (for writing). Exiting...", diag_file);
         $finish; 
       end
       if (verbose >= 1) $display("XTB: User requesting TetraMAX compliant diagnosis file: %0s", diag_file);
       $fdisplay(diagf, "// Serial scan error:       <pat#> \t<pin_name> \t<shift_index> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// USF Parallel scan error: <pat#> \t<pin_name> \t<shift_index> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// DSF Parallel scan error: <pat#> \t<chain_name> \t<cell_index> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// Capture error:           <pat#> \t<pin_name> \t(<expected_value> <simulated_value>)");
       $fdisplay(diagf, "// Cycle based error:          C \t<pin_name> \t<vect_nbr> \t(<expected_value> <simulated_value>)\n\n");

     end 

     memel = memall[data_i]; 
     total_pats = memel[31:0];
     data_i=data_i+1;

     last_pat = -1;

     n_pat_sim = -1;

     start_pat = -1;

     if (total_pats < 0 || |(total_pats) === 1'bx) begin
       $display("XTB Error: Inconsistent total number of patterns (%d). Exiting...",  total_pats);
       $finish;
     end

     if (verbose >= 1) $display("XTB: Total number of patterns  %0d",  total_pats); 
     if (last_pat == -1) last_pat = total_pats - 1;

     `ifdef tmax_n_pattern_sim
     last_pat=`tmax_n_pattern_sim;
     n_pat_sim=`tmax_n_pattern_sim;
     `endif

     `ifdef tmax_test_setup_only_once
     test_setup_only_once = 1;
     `endif

     xtb_sim_mode = 1;
     SSHIFTS = DFSHIFTS;

     ser_pats = 0;
     csim_op = -1;

     `ifdef tmax_serial
       if (~(`tmax_serial & 1'b1) == 1'b0) 
         ser_pats = last_pat + 1;
       else 
         ser_pats = `tmax_serial + 0;
       if (ser_pats > 0)
       csim_op = 0;
       `ifdef tmax_parallel 
         if (~(`tmax_parallel & 1'b1) == 1'b0) SSHIFTS = DFSHIFTS;
         else SSHIFTS = `tmax_parallel + 0; 
         if (ser_pats  >= last_pat + 1) begin	 
           csim_op = 2; 
         end 
         else if (ser_pats == 0)
           csim_op = 1;
       `endif
     `else 
       `ifdef tmax_parallel
         csim_op = 1;
         if (~(`tmax_parallel & 1'b1) == 1'b0) SSHIFTS = DFSHIFTS;
         else SSHIFTS = `tmax_parallel + 0; 
       `endif 
     `endif
     if (SSHIFTS < 0) begin
       $display("XTB Error: Passing negative value (%0d) of serial shifts in parallel mode. Exiting...",  SSHIFTS);
       $finish; 
     end

     process_rtops;
     `ifdef tmax_serial_timing 
       sertmg = 1;
       if (xtb_sim_mode == 1) $display("XTB: Parallel simulation (timing and vector) extended to match serial simulation");
     `else 
       sertmg = 0; 
     `endif


     $display("XTB: Starting %0s simulation of %0d pattern%s", xtb_sim_mode == 0 ? "serial" : "parallel", xtb_sim_mode == 0 ? ((ser_pats>last_pat || ser_pats==0)?(last_pat+1):ser_pats): last_pat + 1, (xtb_sim_mode!=0 || ser_pats>1)?"s":"");
     if (xtb_sim_mode) begin 
       $display("XTB: Using %0d serial shifts", SSHIFTS);
     end

     if (SSHIFTS >= MAXCHLEN)  begin 
       $display("XTB Warning: serial shifts (%0d) equals or exceeds max chain length (%0d). Performing full serial scan... ", SSHIFTS, MAXCHLEN); 
       xtb_sim_mode = 0;	
     end 

     if (diagm==2 && xtb_sim_mode==1)  begin 
       $display("XTB Warning: cannot display cycle-based diagnostic messages in parallel load mode simulation. Simulation will display pattern-based diagnostic messages."); 
       diagm = 1;	
     end 

     while (cur_pat <= last_pat && end_pat != 1) begin 
       memel = memall[data_i];
       opcode = memel[15:0];
       cur_stmt = -1;
       args = 'b0;
       case (opcode)
         'd`EndPat:  begin
                       cur_stmt = `EndPat;
                       end_pat = 1;
                     end
         'd`IncPat:  begin
                       cur_stmt = `IncPat;
                       cur_pat = cur_pat + 1;
                       v_count_per_pat = 0;
                       nbpats = nbpats+1;

                     end
         'd`SetLastReseed:  begin
                       cur_stmt = `SetLastReseed;
                       `ifdef tmax_fast_reseed
                       set_last_reseed = memel[17:16];
                       `else
                       set_last_reseed = 1;
                       `endif
                     end
         'd`SetValidStrobe:  begin
                       cur_stmt = `SetValidStrobe;
                     end
         'd`SetForceSI:  begin
                       cur_stmt = `SetForceSI;
                     end
         'd`SetPat:  begin
                       cur_stmt = `SetPat;
                       v_count_per_pat = 0;
                       if (cur_pat==-1) begin first_pat = memel[43:16]; cur_pat = first_pat; end
                       else cur_pat = memel[43:16];
                       if (start_pat==-1) start_pat = memel[43:16];
                       last_pat = last_pat + cur_pat; 
                       if (n_pat_sim>0) last_pat = start_pat+n_pat_sim;
                       nbpats = nbpats+1;  
                     end
         'd`WFTStmt: begin
                       cur_stmt = `WFTStmt;
                       resolve_wft(memel[17:16]);
                     end 
         'd`ConditionStmt, 'd`FixedStmt, 'd`VectorStmt: begin
           if (opcode == 'd`ConditionStmt) cur_stmt = 'd`ConditionStmt;
           else 	cur_stmt='d`VectorStmt;
           nargs = memel[22:16];
           na = 0;
           while (na<nargs) begin
             data_i = data_i + 1;
             memel = memall[data_i];
             assign_val(memel[SIG_IDS_W-1:0], memel[2*MAX_WIDTH+SIG_IDS_W-1:SIG_IDS_W]);
             na = na + 1;
           end
           if (opcode == `VectorStmt) assign_stmt(the_wft_id);
          end 
          'd`GenLoopStmt: begin: GenLoop_BLOCK
            cur_stmt = `GenLoopStmt;
            lp_count = 1;
            lp_addr = data_i;
            lp_max = memel[31:16];
            $display("\nXTB: starting loop statement with %0d iterations", lp_max); 
          end 
          'd`EndGenLoopStmt: begin: EndLoop_BLOCK
            cur_stmt = `EndGenLoopStmt;
            $display("\nXTB: loop iteration %0d/%0d done.", lp_count, lp_max);
            lp_count = lp_count+1;
            if (lp_count <= lp_max) begin
              data_i = lp_addr;
            end 
         end 
         'd`test_setupStmt: begin: test_setup_BLOCK
           cur_stmt = `test_setupStmt;
           set_args(memel[22:16]);
             test_setup(sid_args, sval_args);
         end 
         'd`load_unloadStmt: begin: load_unload_BLOCK
           cur_stmt = `load_unloadStmt;
            na = 0; nargs = 'b0; sid_args = 'b0; sval_args = 'b0;
            nargs = memel[22:16];
            while (na < nargs) begin
              data_i = data_i + 1;
              memel = memall[data_i];
              if (memel[SIG_IDS_W-1:0] > SIG_IDS-1) begin
                $display("\nXTB Error: Passing wrong signal ID (%b), valid range is 1..%d. Exiting...", memel[SIG_IDS_W-1:0], SIG_IDS-1);
                $finish;
              end
              sid_args[memel[SIG_IDS_W-1:0]] = 1'b1;
              case (memel[SIG_IDS_W-1:0])
               'd`_si , 'd`si: begin LOAD[0] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               'd`_so , 'd`so: begin UNLOAD[0] = memel[MAXCHLEN-1+SIG_IDS_W:SIG_IDS_W]; end 
               default: begin  
                 $display("\nXTB Error: Wrong signal argument (%0s) passed to load_unload procedure. Exiting...", SignalIDName[memel[SIG_IDS_W-1:0]]);
                 $finish; 
               end 
             endcase 
             na = na+1;
           end
             load_unload(sid_args, sval_args);
         end 
         'd`multiclock_captureStmt: begin: multiclock_capture_BLOCK
           cur_stmt = `multiclock_captureStmt;
           set_args(memel[22:16]);
             multiclock_capture(sid_args, sval_args);
         end 
         default: begin $display("\nXTB Error: Unrecognized code %0h, @ inst %0d", opcode, data_i); $finish; end 
       endcase 
       data_i = data_i + 1;
       popcode = opcode;
       if (verbose >= 3) display_stmt(cur_stmt);
     end 
     $display("XTB: Simulation of %0d pattern%s completed with %0d mismatch%s (time: %0t, cycles: %0d)\n", nbpats+end_pat-1, (nbpats==1)?"":"s", nbfails, (nbfails==1)?"":"es", $time, v_count); 

     if (diagf) $fclose(diagf);
     ->end_part;
   end 


   task init_rtops;
     integer i;
   begin
     for (i=0; i<`NBRTOPS; i=i+1)
       rt_ops[i] = -1;
     RT_OPS [4] = "tmax_n_pattern_sim";
     RT_OPS [5] = "tmax_serial";
     RT_OPS [6] = "tmax_parallel";
     RT_OPS [0] = "tmax_msg";
     RT_OPS [1] = "tmax_rpt";
     RT_OPS [7] = "tmax_test_setup_only_once";
     RT_OPS [8] = "tmax_usf_debug_strobe_mode";
     RT_OPS [2] = "tmax_diag_file";
     RT_OPS [3] = "tmax_n_error_stop";
   end 
   endtask

   task process_rtops;
     integer sim_op, p_mode;
     integer i, r;
   begin
     sim_op = -1;
     init_rtops;
     for (i=0; i<`NBRTOPS; i=i+1)
       r = $value$plusargs ({RT_OPS[i], "=%d"}, rt_ops[i]);
     if ((rt_ops[4] > -1)) begin last_pat = rt_ops[4]; n_pat_sim = rt_ops[4]; end
     if (last_pat != total_pats-1) begin
       display_ops ((rt_ops[4] > 0), last_pat, RT_OPS[4]);
       $display("XTB: User requesting simulation of first %0d patterns", last_pat);
     end 
     if (last_pat >= total_pats && total_pats > 1) begin
       $display("XTB Warning: Requested simulation patterns (%0d) exceeds total pattern count (%0d). Adjusting...", last_pat+1, total_pats);
       last_pat = total_pats-1;
     end 
     else if (last_pat < 0 && total_pats != 0)  begin 
       $display("XTB Error: User requesting simulating wrong number of patterns (%0d). Exiting... ", last_pat+1);
       $finish;
     end
     if ((rt_ops[5] > 0)) begin
       if (rt_ops[5]==0) ser_pats = last_pat + 1;
       else ser_pats = rt_ops[5];
       sim_op = 0;
     end 
     else if (rt_ops[5] != 0 &&  ($test$plusargs ("tmax_serial"))) begin
       ser_pats = last_pat + 1;
       rt_ops[5] = ser_pats;
       sim_op = 0;
     end
     if ((rt_ops[5]>0) || (csim_op==0 || csim_op==2)) display_ops ((rt_ops[5]>0), ser_pats, RT_OPS[5]);
     p_mode = ((rt_ops[6] > -1) || ($test$plusargs ("tmax_parallel")))?1:0;
     if (p_mode) begin
       SSHIFTS = (rt_ops[6] > -1)?rt_ops[6]:DFSHIFTS;
       if (sim_op == -1)
         sim_op = 1;
       else  if (ser_pats  < last_pat + 1)
         sim_op = 0;
       else 
         sim_op = 2;
     end 
     if (p_mode || (csim_op==1 || csim_op==2)) display_ops (p_mode, SSHIFTS, RT_OPS[6]);
     if (sim_op > -1)
       set_sim_ops (sim_op);
     else if (csim_op > -1)
       set_sim_ops (csim_op);
     if (rt_ops[0] > -1) begin
       verbose = rt_ops[0];
     end
     if (verbose != 0) 
       display_ops ((rt_ops[0]>-1), verbose, RT_OPS[0]);
     if (rt_ops[1] > -1) begin
       rep_pat =  rt_ops[1];
     end
     if (rep_pat != 5) 
       display_ops ((rt_ops[1]>-1), rep_pat, RT_OPS[1]);
     if (rt_ops[7] != 0 && ($test$plusargs ("tmax_test_setup_only_once"))) begin
       test_setup_only_once = 1;
       rt_ops[7] = 1;
     end
     if (test_setup_only_once > 0) begin
       display_ops ((rt_ops[7]>-1), test_setup_only_once, RT_OPS[7]);
     end
   end 
   endtask

   task display_ops;
     input reg rt;
     input integer val;
     input reg [32*8:1] opname;
   begin
     $display("XTB: Setting %0s option \"%0s\" to %0d.", (rt==1)?"runtime":"compile-time",  opname, val);
   end 
   endtask

   task display_help;
   integer op;
   begin
     init_rtops;
     $display("\n\n\t\t----------------------- Runtime Help ------------------------------\n");
     $display("XTB: Usage is: <sim_exec> +opt1=val1 +opt2=val2...");
     $display("     where  <sim_exec> is the simulation exec name, and opt1 opt2 are available options and val1, val2 their corresponding values.");
     $display("     Available runtime options are:");
     op = 0;
     while (op < `NBRTOPS) begin
       $display("        +%0s", RT_OPS[op]);
       op = op + 1;
     end
     $display("\n      E.g.: simv +tmax_serial=2 +tmax_msg=2, runs first 2 patterns in serial and remaining in parallel, and set the verbose msg level to 2.");
     $display("\n Note: Runtime options override corresponding compile-time options.");
     $display("\n       Please refer to the User's Guide for details regarding each option.");
     $display("\n\t\t-------------------------------------------------------------------\n");
   end 
   endtask

   task set_sim_ops;
     input integer smode;
   begin
     if (smode==0) begin 
       xtb_sim_mode = 0;
       $write("XTB: Enabling serial simulation for");
       if (ser_pats < last_pat + 1) begin
         if (ser_pats==1) $write(" the first pattern.\n");
         else $write(" first %0d patterns.\n", ser_pats);
       end else 
         $write(" all patterns.\n");
     end
     else if (smode==1) begin 
       $write("XTB: Enabling parallel simulation with %0d serial shift(s).\n", SSHIFTS);
       xtb_sim_mode = 1;
     end 
     else  if (smode==2) begin
       $display("XTB Warning: requesting full serial simulation and full parallel simulation in the same time. Performing default parallel simulation mode...");
       xtb_sim_mode = 1;
     end 
   end 
   endtask

   task check_max_error_limit;
     begin
     if( rt_ops[3] > -1 && nbfails == rt_ops[3])    finish_at_max_error;
   end
     endtask

   task finish_at_max_error;
     begin
     $display("XTB: Simulation of %0d pattern%s completed with %0d mismatch%s (time: %0t, cycles: %0d)\n", cur_pat-first_pat+1, (cur_pat-first_pat+1==1)?"":"s", nbfails, (nbfails==1)?"":"es", $time, v_count); 
     $finish(0);
     end
     endtask


   initial begin: _burst__pattern__init_unit

     `ifdef tmax_fsdb
       $fsdbDumpvars;
     `endif


     for (n=0; n<SIG_IDS; n=n+1) SignalIDWidth[n] = 0;
     SignalIDName[0] = "clk";
     SignalIDType[0] = 0; //clk
     SignalIDWidth[0] = 1; //clk
     SignalIDName[1] = "reset";
     SignalIDType[1] = 0; //reset
     SignalIDWidth[1] = 1; //reset
     SignalIDName[2] = "N1_wire";
     SignalIDType[2] = 0; //N1_wire
     SignalIDWidth[2] = 1; //N1_wire
     SignalIDName[3] = "N18_wire";
     SignalIDType[3] = 0; //N18_wire
     SignalIDWidth[3] = 1; //N18_wire
     SignalIDName[4] = "N35_wire";
     SignalIDType[4] = 0; //N35_wire
     SignalIDWidth[4] = 1; //N35_wire
     SignalIDName[5] = "N52_wire";
     SignalIDType[5] = 0; //N52_wire
     SignalIDWidth[5] = 1; //N52_wire
     SignalIDName[6] = "N69_wire";
     SignalIDType[6] = 0; //N69_wire
     SignalIDWidth[6] = 1; //N69_wire
     SignalIDName[7] = "N86_wire";
     SignalIDType[7] = 0; //N86_wire
     SignalIDWidth[7] = 1; //N86_wire
     SignalIDName[8] = "N103_wire";
     SignalIDType[8] = 0; //N103_wire
     SignalIDWidth[8] = 1; //N103_wire
     SignalIDName[9] = "N120_wire";
     SignalIDType[9] = 0; //N120_wire
     SignalIDWidth[9] = 1; //N120_wire
     SignalIDName[10] = "N137_wire";
     SignalIDType[10] = 0; //N137_wire
     SignalIDWidth[10] = 1; //N137_wire
     SignalIDName[11] = "N154_wire";
     SignalIDType[11] = 0; //N154_wire
     SignalIDWidth[11] = 1; //N154_wire
     SignalIDName[12] = "N171_wire";
     SignalIDType[12] = 0; //N171_wire
     SignalIDWidth[12] = 1; //N171_wire
     SignalIDName[13] = "N188_wire";
     SignalIDType[13] = 0; //N188_wire
     SignalIDWidth[13] = 1; //N188_wire
     SignalIDName[14] = "N205_wire";
     SignalIDType[14] = 0; //N205_wire
     SignalIDWidth[14] = 1; //N205_wire
     SignalIDName[15] = "N222_wire";
     SignalIDType[15] = 0; //N222_wire
     SignalIDWidth[15] = 1; //N222_wire
     SignalIDName[16] = "N239_wire";
     SignalIDType[16] = 0; //N239_wire
     SignalIDWidth[16] = 1; //N239_wire
     SignalIDName[17] = "N256_wire";
     SignalIDType[17] = 0; //N256_wire
     SignalIDWidth[17] = 1; //N256_wire
     SignalIDName[18] = "N273_wire";
     SignalIDType[18] = 0; //N273_wire
     SignalIDWidth[18] = 1; //N273_wire
     SignalIDName[19] = "N290_wire";
     SignalIDType[19] = 0; //N290_wire
     SignalIDWidth[19] = 1; //N290_wire
     SignalIDName[20] = "N307_wire";
     SignalIDType[20] = 0; //N307_wire
     SignalIDWidth[20] = 1; //N307_wire
     SignalIDName[21] = "N324_wire";
     SignalIDType[21] = 0; //N324_wire
     SignalIDWidth[21] = 1; //N324_wire
     SignalIDName[22] = "N341_wire";
     SignalIDType[22] = 0; //N341_wire
     SignalIDWidth[22] = 1; //N341_wire
     SignalIDName[23] = "N358_wire";
     SignalIDType[23] = 0; //N358_wire
     SignalIDWidth[23] = 1; //N358_wire
     SignalIDName[24] = "N375_wire";
     SignalIDType[24] = 0; //N375_wire
     SignalIDWidth[24] = 1; //N375_wire
     SignalIDName[25] = "N392_wire";
     SignalIDType[25] = 0; //N392_wire
     SignalIDWidth[25] = 1; //N392_wire
     SignalIDName[26] = "N409_wire";
     SignalIDType[26] = 0; //N409_wire
     SignalIDWidth[26] = 1; //N409_wire
     SignalIDName[27] = "N426_wire";
     SignalIDType[27] = 0; //N426_wire
     SignalIDWidth[27] = 1; //N426_wire
     SignalIDName[28] = "N443_wire";
     SignalIDType[28] = 0; //N443_wire
     SignalIDWidth[28] = 1; //N443_wire
     SignalIDName[29] = "N460_wire";
     SignalIDType[29] = 0; //N460_wire
     SignalIDWidth[29] = 1; //N460_wire
     SignalIDName[30] = "N477_wire";
     SignalIDType[30] = 0; //N477_wire
     SignalIDWidth[30] = 1; //N477_wire
     SignalIDName[31] = "N494_wire";
     SignalIDType[31] = 0; //N494_wire
     SignalIDWidth[31] = 1; //N494_wire
     SignalIDName[32] = "N511_wire";
     SignalIDType[32] = 0; //N511_wire
     SignalIDWidth[32] = 1; //N511_wire
     SignalIDName[33] = "N528_wire";
     SignalIDType[33] = 0; //N528_wire
     SignalIDWidth[33] = 1; //N528_wire
     SignalIDName[34] = "si";
     SignalIDType[34] = 0; //si
     SignalIDWidth[34] = 1; //si
     SignalIDName[35] = "se";
     SignalIDType[35] = 0; //se
     SignalIDWidth[35] = 1; //se
     SignalIDName[36] = "N545";
     SignalIDType[36] = 1; //N545
     SignalIDWidth[36] = 1; //N545
     SignalIDName[37] = "N1581";
     SignalIDType[37] = 1; //N1581
     SignalIDWidth[37] = 1; //N1581
     SignalIDName[38] = "N1901";
     SignalIDType[38] = 1; //N1901
     SignalIDWidth[38] = 1; //N1901
     SignalIDName[39] = "N2223";
     SignalIDType[39] = 1; //N2223
     SignalIDWidth[39] = 1; //N2223
     SignalIDName[40] = "N2548";
     SignalIDType[40] = 1; //N2548
     SignalIDWidth[40] = 1; //N2548
     SignalIDName[41] = "N2877";
     SignalIDType[41] = 1; //N2877
     SignalIDWidth[41] = 1; //N2877
     SignalIDName[42] = "N3211";
     SignalIDType[42] = 1; //N3211
     SignalIDWidth[42] = 1; //N3211
     SignalIDName[43] = "N3552";
     SignalIDType[43] = 1; //N3552
     SignalIDWidth[43] = 1; //N3552
     SignalIDName[44] = "N3895";
     SignalIDType[44] = 1; //N3895
     SignalIDWidth[44] = 1; //N3895
     SignalIDName[45] = "N4241";
     SignalIDType[45] = 1; //N4241
     SignalIDWidth[45] = 1; //N4241
     SignalIDName[46] = "N4591";
     SignalIDType[46] = 1; //N4591
     SignalIDWidth[46] = 1; //N4591
     SignalIDName[47] = "N4946";
     SignalIDType[47] = 1; //N4946
     SignalIDWidth[47] = 1; //N4946
     SignalIDName[48] = "N5308";
     SignalIDType[48] = 1; //N5308
     SignalIDWidth[48] = 1; //N5308
     SignalIDName[49] = "N5672";
     SignalIDType[49] = 1; //N5672
     SignalIDWidth[49] = 1; //N5672
     SignalIDName[50] = "N5971";
     SignalIDType[50] = 1; //N5971
     SignalIDWidth[50] = 1; //N5971
     SignalIDName[51] = "N6123";
     SignalIDType[51] = 1; //N6123
     SignalIDWidth[51] = 1; //N6123
     SignalIDName[52] = "N6150";
     SignalIDType[52] = 1; //N6150
     SignalIDWidth[52] = 1; //N6150
     SignalIDName[53] = "N6160";
     SignalIDType[53] = 1; //N6160
     SignalIDWidth[53] = 1; //N6160
     SignalIDName[54] = "N6170";
     SignalIDType[54] = 1; //N6170
     SignalIDWidth[54] = 1; //N6170
     SignalIDName[55] = "N6180";
     SignalIDType[55] = 1; //N6180
     SignalIDWidth[55] = 1; //N6180
     SignalIDName[56] = "N6190";
     SignalIDType[56] = 1; //N6190
     SignalIDWidth[56] = 1; //N6190
     SignalIDName[57] = "N6200";
     SignalIDType[57] = 1; //N6200
     SignalIDWidth[57] = 1; //N6200
     SignalIDName[58] = "N6210";
     SignalIDType[58] = 1; //N6210
     SignalIDWidth[58] = 1; //N6210
     SignalIDName[59] = "N6220";
     SignalIDType[59] = 1; //N6220
     SignalIDWidth[59] = 1; //N6220
     SignalIDName[60] = "N6230";
     SignalIDType[60] = 1; //N6230
     SignalIDWidth[60] = 1; //N6230
     SignalIDName[61] = "N6240";
     SignalIDType[61] = 1; //N6240
     SignalIDWidth[61] = 1; //N6240
     SignalIDName[62] = "N6250";
     SignalIDType[62] = 1; //N6250
     SignalIDWidth[62] = 1; //N6250
     SignalIDName[63] = "N6260";
     SignalIDType[63] = 1; //N6260
     SignalIDWidth[63] = 1; //N6260
     SignalIDName[64] = "N6270";
     SignalIDType[64] = 1; //N6270
     SignalIDWidth[64] = 1; //N6270
     SignalIDName[65] = "N6280";
     SignalIDType[65] = 1; //N6280
     SignalIDWidth[65] = 1; //N6280
     SignalIDName[66] = "N6287";
     SignalIDType[66] = 1; //N6287
     SignalIDWidth[66] = 1; //N6287
     SignalIDName[67] = "N6288";
     SignalIDType[67] = 1; //N6288
     SignalIDWidth[67] = 1; //N6288
     SignalIDName[68] = "so";
     SignalIDType[68] = 1; //so
     SignalIDWidth[68] = 1; //so
     SignalIDName[69] = "_pi";
     SignalIDType[69] = 3; //_pi
     SignalIDWidth[69] = 36; //_pi
     SignalIDName[70] = "all_inputs";
     SignalIDType[70] = 3; //all_inputs
     SignalIDWidth[70] = 36; //all_inputs
     SignalIDName[71] = "_po";
     SignalIDType[71] = 3; //_po
     SignalIDWidth[71] = 33; //_po
     SignalIDName[72] = "_si";
     SignalIDType[72] = 3; //_si
     SignalIDWidth[72] = 1; //_si
     SignalIDName[73] = "all_outputs";
     SignalIDType[73] = 3; //all_outputs
     SignalIDWidth[73] = 33; //all_outputs
     SignalIDName[74] = "_clk";
     SignalIDType[74] = 3; //_clk
     SignalIDWidth[74] = 2; //_clk
     SignalIDName[75] = "_so";
     SignalIDType[75] = 3; //_so
     SignalIDWidth[75] = 1; //_so
     WFTIDName[0] = "_multiclock_capture_WFT_";
     WFTIDName[1] = "_default_WFT_";
     StmtNames[0] = "SetLastReseed";
     StmtNames[1] = "EndPat";
     StmtNames[2] = "IncPat";
     StmtNames[3] = "SetPat";
     StmtNames[4] = "WFTStmt";
     StmtNames[5] = "ConditionStmt";
     StmtNames[6] = "VectorStmt";
     StmtNames[7] = "FixedStmt";
     StmtNames[8] = "GenLoopStmt";
     StmtNames[9] = "EndGenLoopStmt";
     StmtNames[10] = "GenTestSetupStmt";
     StmtNames[11] = "EndGenTestSetupStmt";
     StmtNames[12] = "SetForceSI";
     StmtNames[13] = "SetValidStrobe";
     StmtNames[14] = "AnnotationStmt";
     StmtNames[15] = "SetWPack";
     StmtNames[16] = "SetRPack";
     StmtNames[17] = "test_setupStmt";
     StmtNames[18] = "load_unloadStmt";
     StmtNames[19] = "multiclock_captureStmt";

     $display("%s",`MAXTB_H_S);
     $display("%s",`MAXTB_HEADER);
     $display("%s\n",`MAXTB_H_S);

     if ( $test$plusargs ("tmax_help") ) begin
       display_help;
       $finish(0);
     end

     $timeformat(-9,2," ns",19);

     `ifdef tmax_test_data_file 
       tdfm = 1;
       TDATA_FILE = `tmax_test_data_file ;
     `else
       tdfm = 0;
       TDATA_FILE = `TDATA_FILE ;
     `endif


     `ifdef tmax_diag_file 
       diagm = 1;
       diag_file = `tmax_diag_file ;
     `else
       tdfm = 0;
       diag_file = "" ;
     `endif

     `ifdef tmax_vcde
       $display("XTB: Dumping Extended VCD information in file \"c6288Tb.vcd\"");
       $dumpports(`XTB_DUT_HIER, "c6288Tb.vcd");
     `endif

     `ifdef tmax_msg
       verbose = `tmax_msg ;
     `else
       verbose = 0 ;
     `endif

     `ifdef tmax_debug
     if (~(`tmax_debug & 1'b1) == 1'b0)
       debug = 1;
     else
       debug = `tmax_debug + 0 ;
     `else
     debug = 0 ;
     `endif

     `ifdef tmax_rpt
     rep_pat = `tmax_rpt ;
     `else
     rep_pat = 5 ;
     `endif

     test_setup_runs = 0;

     set_last_reseed = 1;
     CH_NAMES[0] = "1";
     CH_PINS[0] = "so";
     CH_OUTINV[0] = 64'b0101010101010101010101010101010101010101010101011101010101010101;
     CH_INPINV[0] = 64'b1010101010101010101010101010101010101010101010100010101010101010;
     CT_OUTINV[0] = 64'b0111111111111111111111111111111111111111111111110011111111111111;

     diagm = 0;
     diag_file = "";

     `ifdef tmax_diag 
       diagm = `tmax_diag;
     `endif

     -> start_part;
     @(end_part) #0;
     $finish(0);

   end

 endmodule
